const axios = require('axios');
const ANTHROPIC_API_URL = 'https://api.anthropic.com/v1/messages';  // Updated endpoint
const ANTHROPIC_API_KEY = process.env.ANTHROPIC_API_KEY;

// Check API status function
exports.checkStatus = async () => {
  if (!ANTHROPIC_API_KEY) {
    return {
      isAvailable: false,
      message: "Anthropic API key is not configured",
      models: []
    };
  }
  
  try {
    // Make a simple request to test the API key
    const response = await anthropicAxios.post('', {
      model: "claude-3-opus-20240229",
      messages: [
        { role: "user", content: "Hello" }
      ],
      max_tokens: 5,
    });
    
    return {
      isAvailable: true,
      message: "Anthropic API is configured and working",
      models: ["claude-3-opus-20240229", "claude-3-haiku-20240307"]
    };
  } catch (error) {
    return {
      isAvailable: false,
      message: `Anthropic API error: ${error.message}`,
      models: []
    };
  }
};

// Add a simple mock API for development when API key is invalid
const useMockApi = !ANTHROPIC_API_KEY; // Only use mock API when API key is not available

// EMERGENCY FIX: Clear the cache at startup to ensure a clean state
console.log('🧨🧨🧨 EMERGENCY: CLEARING ENTIRE CACHE AT STARTUP 🧨🧨🧨');
const cache = new Map();

// Add a way to distinguish force refresh calls 
// by using a completely different mock API response pattern
const MOCK_API_VERSION = 2; // Bump this to easily get different responses

// Mock API for when the API key is invalid or for testing purposes
const mockApiResponse = async (prompt, options = {}) => {
  const { forceRefresh = false } = options;
  
  // FIXED: Convert string "true" to boolean true
  const shouldForceRefresh = forceRefresh === true || forceRefresh === "true";
  
  const currentTime = new Date().toISOString();
  const randomId = Math.random().toString(36).substring(2, 8);
  
  console.log(`Using mock API response with original forceRefresh=${forceRefresh} (${typeof forceRefresh}), converted to: ${shouldForceRefresh}`);
  console.log(`Prompt:`, prompt.substring(0, 50) + '...');
  console.log(`⚠️ INSIDE MOCK API RESPONSE: forceRefresh=${forceRefresh}, shouldForceRefresh=${shouldForceRefresh}`);
  
  // ALWAYS generate completely different content for force refresh
  // to make it obvious if the cache is working or not
  if (shouldForceRefresh) {
    console.log(`🔥 GENERATING COMPLETELY DIFFERENT FORCE-REFRESHED MOCK RESPONSE`);
  }
  
  // Use the forceRefresh parameter to generate different responses for testing
  const forceRefreshSuffix = shouldForceRefresh ? 
    `\n\n[THIS RESPONSE WAS FORCE-REFRESHED AND UNIQUELY GENERATED AT ${currentTime} (ID: ${randomId}, API v${MOCK_API_VERSION})]` : 
    `\n\n[Cached response from mock API - timestamp: ${currentTime.split('T')[1]}]`;
  
  // Simple responses based on the request type - with more variation for forceRefresh
  if (prompt.includes('summarize') || prompt.includes('Summarize')) {
    // Create completely different content for force refresh vs regular requests
    if (shouldForceRefresh) {
      return `**COMPLETELY NEW FORCE-REFRESHED Summary**\n\nThis is a brand new summary that would NEVER be generated by the cache. It was generated at ${currentTime} with ID: ${randomId}.\n\nThis summary includes points that are unique to force-refreshed content.\n\nVersion ${MOCK_API_VERSION} of the mock API.${forceRefreshSuffix}`;
    } else {
      return `**Standard Cached Summary**\n\nThis is a regular mock summary that would be returned from cache. Generated at ${currentTime}.\n\nIt contains only information that would be in a cached response.${forceRefreshSuffix}`;
    }
  } else if (prompt.includes('Format') || prompt.includes('format')) {
    // Return completely different content for formatting based on forceRefresh
    if (shouldForceRefresh) {
      return `FORCE-REFRESHED TRANSCRIPT FORMAT (v${MOCK_API_VERSION})\n\nSpeaker 1: This is special content that is only shown when force-refreshing the cache.\n\nModerator: The input was "${prompt.split('\n\n')[prompt.split('\n\n').length - 1]}"\n\nSpeaker 2: This demonstrates that forceRefresh is working correctly.\n\nGenerated at ${currentTime} with ID: ${randomId}${forceRefreshSuffix}`;
    } else {
      return `STANDARD CACHED TRANSCRIPT FORMAT\n\nNarrator: Below is a formatted version of the transcript.\n\n"${prompt.split('\n\n')[prompt.split('\n\n').length - 1]}"\n\nThis would be returned from cache. Timestamp: ${currentTime}${forceRefreshSuffix}`;
    }
  } else if (prompt.includes('theme') || prompt.includes('Theme')) {
    if (shouldForceRefresh) {
      return `## Force-Refreshed Unique Themes (v${MOCK_API_VERSION})\n\n1. First unique theme (ID: ${randomId})\n2. Second unique theme\n3. Third unique theme that only appears in forced refresh\n4. Fourth unique theme showing cache bypass is working\n\n## SPECIAL Areas of Agreement\nThis content only appears in force-refreshed responses.${forceRefreshSuffix}`;
    } else {
      return `## Standard Cached Themes\n\n1. First standard theme\n2. Second standard theme\n\n## Areas of Agreement\nParticipants agreed on points that would be cached...${forceRefreshSuffix}`;
    }
  } else if (prompt.includes('test')) {
    return `This is a ${shouldForceRefresh ? 'COMPLETELY UNIQUE FORCE-REFRESHED' : 'standard cached'} response for testing. Generated at ${currentTime} with ID: ${randomId}${forceRefreshSuffix}`;
  } else {
    if (shouldForceRefresh) {
      return `FORCE-REFRESHED UNIQUE RESPONSE (v${MOCK_API_VERSION}) - This content is never cached and only appears when forceRefresh=true. Generated at ${currentTime} with ID: ${randomId}${forceRefreshSuffix}`;
    } else {
      return `Standard Cached Response - This would be returned from cache. Generated at ${currentTime}${forceRefreshSuffix}`;
    }
  }
};

// Test simple query function for integration tests
exports.testSimpleQuery = async (text) => {
  // Don't process empty text
  if (!text || text.trim().length === 0) {
    return "No text provided for testing.";
  }
  
  try {
    const testPrompt = `
You are Claude, an AI assistant by Anthropic. Please respond to the following input with a brief, helpful response:

${text}
`;
    
    console.log('Sending test query to Anthropic API...');
    
    // Use mock API if specified or API key is invalid
    if (useMockApi || !ANTHROPIC_API_KEY) {
      console.log('Using mock API for test query');
      const mockResponse = await mockApiResponse(testPrompt);
      return mockResponse;
    }
    
    const response = await retryWithDelay(() => 
      anthropicAxios.post('', {
        messages: [{
          role: "user",
          content: testPrompt
        }],
        model: "claude-3-haiku-20240307", // Use haiku for faster, cheaper responses
        max_tokens: 250,
        temperature: 0.7,
      })
    );
    
    const result = response.data.content[0].text;
    console.log('Successfully generated test response');
    
    return result;
  } catch (error) {
    console.error('Error in test query:', error.response ? error.response.data : error.message);
    return `Error processing your request: ${error.message}`;
  }
};

// Add theme extraction feature
exports.extractThemes = async (text, options = {}) => {
  // Don't process empty or very short text
  if (!text || text.length < 100) {
    return "Text too short to extract themes.";
  }
  
  // FIXED: Strict conversion to boolean and more debugging logs
  // Check cache first, honoring forceRefresh if provided
  const { forceRefresh = false } = options;
  const shouldForceRefresh = forceRefresh === true || forceRefresh === "true";
  
  console.log(`extractThemes called with original forceRefresh=${forceRefresh} (${typeof forceRefresh}), converted to: ${shouldForceRefresh}`);
  console.log(`Full options:`, JSON.stringify(options));
  
  // Override the options object to ensure strict boolean
  const modifiedOptions = {
    ...options,
    forceRefresh: shouldForceRefresh
  };
  
  // Only check cache if we're not forcing a refresh
  const cachedThemes = getCachedResult('themes', text, modifiedOptions);
  if (cachedThemes) {
    console.log('Using cached themes result');
    return cachedThemes;
  }
  
  console.log('No cache hit or forceRefresh=true, generating fresh themes');
  
  try {
    const themeExtractionPrompt = `
You are an expert dialogue analyst specializing in thematic analysis. Analyze this transcript and identify:

1. The 3-5 main themes that emerged in the conversation
2. Key supporting points or evidence for each theme
3. Areas of agreement among participants
4. Areas of divergence or questions that remain unresolved
5. Potential next steps for further exploration

Present your analysis in a structured format with clear headings.

Dialogue transcript:
${text}
`;

    console.log('Sending theme extraction request to AI API...');
    
    // Use mock API if specified or API key is invalid
    if (useMockApi || !ANTHROPIC_API_KEY) {
      console.log('Using mock API for theme extraction with options:', JSON.stringify(options));
      console.log('🔍 DIAGNOSTICS - forceRefresh:', forceRefresh, 'shouldForceRefresh:', shouldForceRefresh);
      
      // EXTREME EMERGENCY FIX: Nuke the cache entirely for this request if forceRefresh requested
      if (shouldForceRefresh) {
        // First clear by explicit key
        console.log('🧨 EMERGENCY: Explicitly clearing cache key for this operation');
        const key = `themes-${Buffer.from(text).toString('base64').substring(0, 100)}`;
        if (cache.has(key)) {
          console.log(`🗑️ EMERGENCY DELETING CACHE ENTRY FOR ${key.substring(0, 20)}...`);
          cache.delete(key);
        }
        
        // For absolutely critical situations, clear all matching keys
        console.log('🚨 NUCLEAR OPTION: Clearing ALL themes caches');
        for (const cacheKey of cache.keys()) {
          if (cacheKey.startsWith('themes-')) {
            console.log(`💥 FORCE CLEARING CACHE: ${cacheKey.substring(0, 20)}...`);
            cache.delete(cacheKey);
          }
        }
        console.log('✅ Cache clearing completed for themes operation');
      }
      
      // CRITICAL FIX: Make sure we pass the converted shouldForceRefresh value, not the original options
      const modifiedOptions = { forceRefresh: shouldForceRefresh };
      console.log('🔧 Using modified options with explicit boolean:', JSON.stringify(modifiedOptions));
      
      const mockThemes = await mockApiResponse(themeExtractionPrompt, modifiedOptions);
      
      // Only cache the result if not using forceRefresh
      if (!shouldForceRefresh) {
        setCacheResult('themes', text, mockThemes);
        console.log('Caching themes result with forceRefresh=' + shouldForceRefresh);
      } else {
        console.log('Not caching result because forceRefresh=true');
      }
      return mockThemes;
    }
    
    const response = await retryWithDelay(() => 
      anthropicAxios.post('', {
        messages: [{
          role: "user",
          content: themeExtractionPrompt
        }],
        model: "claude-3-opus-20240229",
        max_tokens: 600,
        temperature: 0.3,
      })
    );
    
    const themes = response.data.content[0].text;
    console.log('Successfully extracted themes');
    
    // Cache the result
    setCacheResult('themes', text, themes);
    
    return themes;
  } catch (error) {
    console.error('Error extracting themes:', error.response ? error.response.data : error.message);
    return "Unable to extract themes at this time. Please try again later.";
  }
};

// Check for API key and provide clear error if missing
if (!ANTHROPIC_API_KEY) {
  console.error('ANTHROPIC_API_KEY is not set in environment variables. AI features will not work correctly.');
}

// Updated Anthropic API client with current authentication format
const anthropicAxios = axios.create({
  baseURL: ANTHROPIC_API_URL,
  headers: {
    'Content-Type': 'application/json',
    'anthropic-version': '2023-06-01',
    'x-api-key': ANTHROPIC_API_KEY // Use x-api-key auth which works with Claude
  },
});

// Track remaining requests for rate limiting
let remainingRequests = 100; // Arbitrary starting limit
let resetTime = Date.now() + 60000; // Reset after a minute

// Add response interceptor to track rate limits
anthropicAxios.interceptors.response.use(
  (response) => {
    // Update remaining requests based on headers if available
    if (response.headers['x-ratelimit-remaining']) {
      remainingRequests = parseInt(response.headers['x-ratelimit-remaining'], 10);
    } else {
      // If no header, just decrement our counter
      remainingRequests = Math.max(0, remainingRequests - 1);
    }
    
    // Update reset time if available
    if (response.headers['x-ratelimit-reset']) {
      resetTime = parseInt(response.headers['x-ratelimit-reset'], 10) * 1000;
    }
    
    return response;
  },
  (error) => {
    // Handle rate limit errors
    if (error.response && error.response.status === 429) {
      console.error('Rate limit reached with Anthropic API');
      remainingRequests = 0;
      
      // Get reset time from headers if available
      if (error.response.headers['x-ratelimit-reset']) {
        resetTime = parseInt(error.response.headers['x-ratelimit-reset'], 10) * 1000;
      } else {
        // Default to 1 minute if not specified
        resetTime = Date.now() + 60000;
      }
    }
    
    return Promise.reject(error);
  }
);

// Improved caching mechanism to avoid redundant API calls while supporting refresh
// Cache is initialized above at startup
const CACHE_TTL = 2 * 60 * 1000; // 2 minutes (reduced from 30 minutes)

// Export a function for testing purposes - DO NOT USE IN PRODUCTION!
exports.clearCache = () => {
  console.log('🧹 CLEARING ENTIRE CACHE via API module function');
  cache.clear();
  return { success: true, message: 'Cache cleared', timestamp: Date.now() };
};

const getCachedResult = (operation, input, options = {}) => {
  // Extract options and convert to proper boolean - FORCE STRING CONVERSION FOR DEBUGGING
  let forceRefresh = options.forceRefresh;
  console.log(`RAW forceRefresh value received by getCachedResult: ${forceRefresh} (${typeof forceRefresh})`);
  
  // SUPER STRICT conversion to boolean - handle both boolean true and string "true"
  // This is redundant but critical to ensure we catch all cases
  const shouldForceRefresh = (
    forceRefresh === true || 
    forceRefresh === "true" || 
    String(forceRefresh) === "true"
  );
  
  // Log absolutely everything for debugging
  console.log(`🔎 FULL DEBUGGING - getCachedResult for ${operation}:`);
  console.log(`- options received:`, JSON.stringify(options));
  console.log(`- forceRefresh: ${forceRefresh} (${typeof forceRefresh})`);
  console.log(`- shouldForceRefresh converted value: ${shouldForceRefresh} (${typeof shouldForceRefresh})`);
  
  // Generate more precise cache key using more input text for better uniqueness
  const key = `${operation}-${Buffer.from(input).toString('base64').substring(0, 100)}`;
  console.log(`- Cache key generated: ${key.substring(0, 20)}...`);
  
  // ABSOLUTELY SKIP cache if forceRefresh is true and DELETE any existing entry
  if (shouldForceRefresh) {
    console.log(`🔥 BYPASSING CACHE FOR ${operation} - forceRefresh=${forceRefresh} (${typeof forceRefresh}), shouldForceRefresh=${shouldForceRefresh}`);
    // Completely delete any existing cache entry for this key
    if (cache.has(key)) {
      console.log(`🗑️ EMERGENCY DELETION: REMOVING CACHE ENTRY FOR ${key.substring(0, 20)}...`);
      cache.delete(key);
    }
    console.log(`🚫 CACHE LOOKUP BYPASSED - Returning NULL for ${operation} due to forceRefresh`);
    return null;
  }
  
  const cached = cache.get(key);
  
  if (!cached) {
    console.log(`No cache entry found for ${operation}`);
    return null;
  }
  
  // Check if cache entry is expired
  if (Date.now() > cached.expiresAt) {
    console.log(`Cache expired for ${operation}`);
    cache.delete(key);
    return null;
  }
  
  console.log(`Cache hit for ${operation}, expires in ${Math.round((cached.expiresAt - Date.now())/1000)}s`);
  return cached.data;
};

const setCacheResult = (operation, input, result) => {
  // Generate more precise cache key using more input text
  const key = `${operation}-${Buffer.from(input).toString('base64').substring(0, 100)}`;
  const expiryTime = Date.now() + CACHE_TTL;
  
  cache.set(key, {
    data: result,
    expiresAt: expiryTime,
    createdAt: Date.now()
  });
  
  // Set expiration to automatically clear cache entry
  setTimeout(() => {
    if (cache.has(key)) {
      console.log(`Cache entry for ${operation} expired and removed`);
      cache.delete(key);
    }
  }, CACHE_TTL);
  
  console.log(`Cache set for ${operation}, expires at ${new Date(expiryTime).toISOString()}`);
};

// Improved retry logic with rate limit handling
const retryWithDelay = async (fn, retries = 3, delay = 1000) => {
  try {
    // Check rate limits
    if (remainingRequests <= 0) {
      const waitTime = Math.max(0, resetTime - Date.now());
      console.log(`Rate limit reached, waiting ${waitTime}ms before retrying`);
      await new Promise(resolve => setTimeout(resolve, waitTime + 100)); // Add 100ms buffer
    }
    
    return await fn();
  } catch (error) {
    // If we're out of retries, throw the error
    if (retries === 0) throw error;
    
    // Handle different error types
    if (error.response) {
      // API returned an error response
      const status = error.response.status;
      
      // Rate limit error
      if (status === 429) {
        const waitTime = Math.max(0, resetTime - Date.now());
        console.log(`Rate limit error, waiting ${waitTime}ms before retrying`);
        await new Promise(resolve => setTimeout(resolve, waitTime + 100));
        return retryWithDelay(fn, retries - 1, delay);
      }
      
      // Server errors or other retryable errors
      if (status >= 500 || status === 429 || status === 408) {
        console.log(`API error ${status}, retrying in ${delay}ms (${retries} attempts left)`);
        await new Promise(resolve => setTimeout(resolve, delay));
        return retryWithDelay(fn, retries - 1, delay * 2);
      }
      
      // Client errors (not retryable)
      if (status >= 400 && status < 500 && status !== 429) {
        throw error;
      }
    }
    
    // Network errors or other issues
    console.log(`Network error, retrying in ${delay}ms (${retries} attempts left)`);
    await new Promise(resolve => setTimeout(resolve, delay));
    return retryWithDelay(fn, retries - 1, delay * 2);
  }
};

exports.summarizeText = async (text, options = {}) => {
  // Don't process empty or very short text
  if (!text || text.length < 50) {
    return "Transcript too short to summarize.";
  }
  
  // FIXED: Strict conversion to boolean and more debugging logs
  // Check cache first, honoring forceRefresh if provided
  const { forceRefresh = false } = options;
  const shouldForceRefresh = forceRefresh === true || forceRefresh === "true";
  
  console.log(`summarizeText called with original forceRefresh=${forceRefresh} (${typeof forceRefresh}), converted to: ${shouldForceRefresh}`);
  console.log(`Full options:`, JSON.stringify(options));
  
  // Override the options object to ensure strict boolean
  const modifiedOptions = {
    ...options,
    forceRefresh: shouldForceRefresh
  };
  
  // Only check cache if we're not forcing a refresh
  const cachedSummary = getCachedResult('summary', text, modifiedOptions);
  if (cachedSummary) {
    console.log('Using cached summary result');
    return cachedSummary;
  }
  
  console.log('No cache hit or forceRefresh=true, generating fresh summary');
  
  try {
    // Enhanced prompt for better dialogue summarization
    const summarizationPrompt = `
You are an expert dialogue facilitator. Create a concise summary of this dialogue transcript that:

1. Identifies the main topics discussed
2. Captures key insights and important points raised
3. Highlights areas of agreement and consensus
4. Notes questions or areas requiring further exploration
5. Identifies any action items or next steps mentioned
6. Preserves the essence of different perspectives shared

Format the summary in a clear, organized way that would be useful for participants to review later.

Dialogue transcript:
${text}
`;

    console.log('Sending summarization request to AI API...');
    
    // Use mock API if specified or API key is invalid
    if (useMockApi || !ANTHROPIC_API_KEY) {
      console.log('Using mock API for summarization with options:', JSON.stringify(options));
      console.log('🔍 DIAGNOSTICS - forceRefresh:', forceRefresh, 'shouldForceRefresh:', shouldForceRefresh);
      
      // EXTREME EMERGENCY FIX: Nuke the cache entirely for this request if forceRefresh requested
      if (shouldForceRefresh) {
        // First clear by explicit key
        console.log('🧨 EMERGENCY: Explicitly clearing cache key for this operation');
        const key = `summary-${Buffer.from(text).toString('base64').substring(0, 100)}`;
        if (cache.has(key)) {
          console.log(`🗑️ EMERGENCY DELETING CACHE ENTRY FOR ${key.substring(0, 20)}...`);
          cache.delete(key);
        }
        
        // For absolutely critical situations, clear all matching keys
        console.log('🚨 NUCLEAR OPTION: Clearing ALL summary caches');
        for (const cacheKey of cache.keys()) {
          if (cacheKey.startsWith('summary-')) {
            console.log(`💥 FORCE CLEARING CACHE: ${cacheKey.substring(0, 20)}...`);
            cache.delete(cacheKey);
          }
        }
        console.log('✅ Cache clearing completed for summary operation');
      }
      
      // CRITICAL FIX: Make sure we pass the converted shouldForceRefresh value, not the original options
      const modifiedOptions = { forceRefresh: shouldForceRefresh };
      console.log('🔧 Using modified options with explicit boolean:', JSON.stringify(modifiedOptions));
      
      const mockSummary = await mockApiResponse(summarizationPrompt, modifiedOptions);
      
      // Only cache the result if not using forceRefresh
      if (!shouldForceRefresh) {
        setCacheResult('summary', text, mockSummary);
        console.log('Caching summary result with forceRefresh=' + shouldForceRefresh);
      } else {
        console.log('Not caching result because forceRefresh=true');
      }
      return mockSummary;
    }
    
    const response = await retryWithDelay(() => 
      anthropicAxios.post('', {
        messages: [{
          role: "user",
          content: summarizationPrompt
        }],
        model: "claude-3-opus-20240229",
        max_tokens: 400,
        temperature: 0.4,
      })
    );
    
    const summary = response.data.content[0].text;
    console.log('Successfully generated summary');
    
    // Cache the result
    setCacheResult('summary', text, summary);
    
    return summary;
  } catch (error) {
    console.error('Error summarizing text:', error.response ? error.response.data : error.message);
    
    // Better fallback summarization
    try {
      // Extract first sentence from each paragraph as a simple summary technique
      const paragraphs = text.split(/\n\s*\n/);
      const firstSentences = paragraphs
        .map(p => {
          const sentences = p.split(/[.!?]+\s+/);
          return sentences[0];
        })
        .filter(s => s && s.length > 10) // Only include meaningful sentences
        .slice(0, 3); // Take up to 3 sentences
      
      if (firstSentences.length > 0) {
        return firstSentences.join('. ') + '.';
      } else {
        // If we couldn't extract sentences properly, fall back to word count
        const words = text.split(/\s+/);
        return words.slice(0, 50).join(' ') + '...';
      }
    } catch (fallbackError) {
      console.error('Error in fallback summarization:', fallbackError);
      return text.split('.').slice(0, 3).join('.') + '...';
    }
  }
};

exports.analyzeJourneyInsights = async (transcript, options = {}) => {
  // Don't process empty or very short text
  if (!transcript || transcript.length < 20) {
    return {
      content: "Transcript too short to analyze",
      themes: []
    };
  }
  
  // Check cache first, honoring forceRefresh if provided
  const { forceRefresh = false } = options;
  console.log(`analyzeJourneyInsights called with forceRefresh=${forceRefresh}, options:`, JSON.stringify(options));
  
  // Only check cache if we're not forcing a refresh  
  const cachedInsights = getCachedResult('journey-insights', transcript, options);
  if (cachedInsights) {
    console.log('Using cached journey insights result');
    return cachedInsights;
  }
  
  console.log('No cache hit or forceRefresh=true, generating fresh journey insights');
  
  try {
    // Prompt for journey insight extraction
    const insightPrompt = `
You are an expert dialogue analyst specializing in identifying key themes, insights, and patterns in conversations. Analyze this dialogue transcript to identify:

1. The 2-4 most significant themes that emerged
2. Key insights or perspectives shared
3. Questions or areas for further exploration
4. Any shifts in understanding or perspective that occurred

For themes, provide specific labels that could be tracked over time (e.g., "Renewable Energy Solutions", "Policy Reform", "Social Equity").

Format your response as JSON with the following structure:
{
  "content": "A paragraph summarizing the key insights from this transcript segment",
  "themes": ["Theme 1", "Theme 2", "Theme 3"],
  "keyPoints": ["Key point 1", "Key point 2"],
  "questions": ["Question 1", "Question 2"]
}

Dialogue transcript:
${transcript}
`;

    console.log('Sending journey insight analysis request to AI API...');
    
    // Use mock API if specified or API key is invalid
    if (useMockApi || !ANTHROPIC_API_KEY) {
      console.log('Using mock API for journey insights');
      // Create mock insights with detected keywords
      const mockThemes = [];
      if (transcript.toLowerCase().includes('climate')) mockThemes.push('Climate Change');
      if (transcript.toLowerCase().includes('energy') || transcript.toLowerCase().includes('renewable')) mockThemes.push('Renewable Energy');
      if (transcript.toLowerCase().includes('equity') || transcript.toLowerCase().includes('justice')) mockThemes.push('Social Equity');
      if (transcript.toLowerCase().includes('policy') || transcript.toLowerCase().includes('government')) mockThemes.push('Policy Reform');
      if (transcript.toLowerCase().includes('technology') || transcript.toLowerCase().includes('innovation')) mockThemes.push('Technological Innovation');
      if (transcript.toLowerCase().includes('community') || transcript.toLowerCase().includes('local')) mockThemes.push('Community Engagement');
      
      // Ensure we have at least one theme
      if (mockThemes.length === 0) mockThemes.push('General Discussion');
      
      // Generate more detailed mock insights
      const mockKeyPoints = [];
      if (transcript.toLowerCase().includes('climate')) {
        mockKeyPoints.push("Climate change is accelerating and requires urgent action");
      }
      if (transcript.toLowerCase().includes('energy') || transcript.toLowerCase().includes('renewable')) {
        mockKeyPoints.push("Renewable energy is a key solution to reducing carbon emissions");
      }
      if (transcript.toLowerCase().includes('equity') || transcript.toLowerCase().includes('justice')) {
        mockKeyPoints.push("Ensuring equity in climate solutions is essential for lasting change");
      }
      
      // Generate mock questions
      const mockQuestions = [];
      if (mockThemes.includes('Climate Change')) {
        mockQuestions.push("How can we accelerate action on climate change?");
      }
      if (mockThemes.includes('Renewable Energy')) {
        mockQuestions.push("What barriers prevent wider adoption of renewable energy?");
      }
      if (mockThemes.includes('Social Equity')) {
        mockQuestions.push("How can we ensure climate solutions benefit all communities equally?");
      }
      
      // Create a more detailed content analysis
      let contentAnalysis = `This discussion focuses primarily on ${mockThemes.join(', ')}. `;
      
      if (mockThemes.includes('Climate Change')) {
        contentAnalysis += "The dialogue highlights the urgency of addressing climate change and its widespread impacts. ";
      }
      
      if (mockThemes.includes('Renewable Energy')) {
        contentAnalysis += "There is recognition that transitioning to renewable energy sources is critical for sustainability. ";
      }
      
      if (mockThemes.includes('Social Equity')) {
        contentAnalysis += "The conversation emphasizes the importance of making climate solutions accessible and beneficial to all communities, especially those historically marginalized. ";
      }
      
      const mockInsights = {
        content: contentAnalysis,
        themes: mockThemes,
        keyPoints: mockKeyPoints.length > 0 ? mockKeyPoints : ["The discussion touches on important environmental and social topics"],
        questions: mockQuestions.length > 0 ? mockQuestions : ["How can we better integrate these various approaches to sustainability?"]
      };
      
      // Cache the mock result
      setCacheResult('journey-insights', transcript, mockInsights);
      return mockInsights;
    }
    
    const response = await retryWithDelay(() =>
      anthropicAxios.post('', {
        messages: [{
          role: "user",
          content: insightPrompt
        }],
        model: "claude-3-haiku-20240307", // Using smaller model for speed
        max_tokens: 800,
        temperature: 0.3,
        response_format: { type: "json_object" } // Request JSON format
      })
    );
    
    // Parse the JSON response
    try {
      const jsonResponse = JSON.parse(response.data.content[0].text);
      console.log('Successfully analyzed journey insights');
      
      // Cache the result
      setCacheResult('journey-insights', transcript, jsonResponse);
      
      return jsonResponse;
    } catch (parseError) {
      console.error('Error parsing JSON response:', parseError);
      // Try to extract just the JSON part if there's surrounding text
      const jsonMatch = response.data.content[0].text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        try {
          const extractedJson = JSON.parse(jsonMatch[0]);
          setCacheResult('journey-insights', transcript, extractedJson);
          return extractedJson;
        } catch (e) {
          console.error('Error parsing extracted JSON:', e);
        }
      }
      
      // Fallback to simple object if JSON parsing fails
      const fallbackInsights = {
        content: "Analysis of the dialogue transcript",
        themes: transcript.toLowerCase().includes('climate') ? ['Climate Change'] : ['General Discussion'],
        keyPoints: [],
        questions: []
      };
      return fallbackInsights;
    }
  } catch (error) {
    console.error('Error analyzing journey insights:', error.response ? error.response.data : error.message);
    
    // Fallback insights
    const fallbackInsights = {
      content: "Unable to analyze transcript at this time",
      themes: [],
      keyPoints: [],
      questions: []
    };
    return fallbackInsights;
  }
};

exports.formatTranscript = async (text, options = {}) => {
  // Don't process empty or very short text
  if (!text || text.length < 20) {
    return text;
  }
  
  // FIXED: Strict conversion to boolean and more debugging logs
  // Check cache first, honoring forceRefresh if provided
  const { forceRefresh = false } = options;
  const shouldForceRefresh = forceRefresh === true || forceRefresh === "true";
  
  console.log(`formatTranscript called with original forceRefresh=${forceRefresh} (${typeof forceRefresh}), converted to: ${shouldForceRefresh}`);
  console.log(`Full options:`, JSON.stringify(options));
  
  // Override the options object to ensure strict boolean
  const modifiedOptions = {
    ...options,
    forceRefresh: shouldForceRefresh
  };
  
  // Only check cache if we're not forcing a refresh
  const cachedFormat = getCachedResult('format', text, modifiedOptions);
  if (cachedFormat) {
    console.log('Using cached format result');
    return cachedFormat;
  }
  
  console.log('No cache hit or forceRefresh=true, generating fresh formatted transcript');
  
  try {
    // Enhanced prompt for better transcript formatting
    const formattingPrompt = `
You are a dialogue transcript formatter specializing in real-time speech-to-text conversion. Format the following raw transcript into a clear, structured conversation:

1. Identify different speakers and label them consistently
2. Organize content into proper paragraphs
3. Fix grammar, punctuation, and capitalization while preserving the original meaning
4. Maintain the conversational flow and natural language
5. Remove filler words, disfluencies (um, uh, like), and repetitions that don't add value
6. Add appropriate punctuation to spoken text that may lack it
7. Reconstruct meaningful paragraphs from stream-of-consciousness speech
8. Format in a clean, readable dialogue style
9. When speaker identity is ambiguous, make your best guess based on context

Raw speech-to-text transcript:
${text}
`;

    console.log('Sending formatting request to AI API...');
    
    // Use mock API if specified or API key is invalid
    if (useMockApi || !ANTHROPIC_API_KEY) {
      console.log('Using mock API for formatting with options:', JSON.stringify(options));
      console.log('🔍 DIAGNOSTICS - forceRefresh:', forceRefresh, 'shouldForceRefresh:', shouldForceRefresh);
      
      // EMERGENCY FIX: If forceRefresh is requested, explicitly clear any existing cache entry
      // This is a belt-and-suspenders approach to ensure the cache is bypassed
      if (shouldForceRefresh) {
        console.log('🧨 EMERGENCY: Explicitly clearing cache key for this operation');
        // Generate the exact same cache key as in getCachedResult
        const key = `format-${Buffer.from(text).toString('base64').substring(0, 100)}`;
        if (cache.has(key)) {
          console.log(`🗑️ EMERGENCY DELETING CACHE ENTRY FOR ${key.substring(0, 20)}...`);
          cache.delete(key);
        }
      }
      
      // CRITICAL FIX: Make sure we pass the converted shouldForceRefresh value, not the original options
      const modifiedOptions = { forceRefresh: shouldForceRefresh };
      console.log('🔧 Using modified options with explicit boolean:', JSON.stringify(modifiedOptions));
      
      const mockFormatted = await mockApiResponse(formattingPrompt, modifiedOptions);
      
      // Only cache the result if not using forceRefresh
      if (!shouldForceRefresh) {
        setCacheResult('format', text, mockFormatted);
        console.log('Caching format result with forceRefresh=' + shouldForceRefresh);
      } else {
        console.log('Not caching result because forceRefresh=true');
      }
      return mockFormatted;
    }
    
    const response = await retryWithDelay(() =>
      anthropicAxios.post('', {
        messages: [{
          role: "user",
          content: formattingPrompt
        }],
        model: "claude-3-opus-20240229",
        max_tokens: 1500,
        temperature: 0.3,
      })
    );
    
    const formattedText = response.data.content[0].text;
    console.log('Successfully formatted transcript');
    
    // Cache the result
    setCacheResult('format', text, formattedText);
    
    return formattedText;
  } catch (error) {
    console.error('Error formatting transcript:', error.response ? error.response.data : error.message);
    
    // More sophisticated fallback
    try {
      // Simple rule-based formatting as fallback
      let formatted = text;
      
      // Add periods at natural sentence breaks
      formatted = formatted.replace(/([a-z])\s+([A-Z])/g, '$1. $2');
      
      // Capitalize first letters of sentences
      formatted = formatted.replace(/(^|[.!?]\s+)([a-z])/g, (match, p1, p2) => p1 + p2.toUpperCase());
      
      // Add paragraph breaks approximately every 3-4 sentences
      const sentences = formatted.match(/[^.!?]+[.!?]+/g) || [];
      if (sentences.length > 3) {
        formatted = '';
        for (let i = 0; i < sentences.length; i++) {
          formatted += sentences[i];
          if (i > 0 && i % 3 === 0) {
            formatted += '\n\n';
          }
        }
      }
      
      return formatted;
    } catch (fallbackError) {
      console.error('Error in fallback formatting:', fallbackError);
      return text; // Return original text if all else fails
    }
  }
};

// Generic generateResponse method for synthesis service
exports.generateResponse = async (prompt, options = {}) => {
  if (!prompt || prompt.trim().length === 0) {
    return "No prompt provided.";
  }
  
  const { forceRefresh = false, model = 'claude-3-haiku-20240307' } = options;
  const shouldForceRefresh = forceRefresh === true || forceRefresh === "true";
  
  console.log(`generateResponse called with model: ${model}, forceRefresh: ${shouldForceRefresh}`);
  
  // Check cache first, honoring forceRefresh if provided
  const cachedResponse = getCachedResult('response', prompt, { forceRefresh: shouldForceRefresh });
  if (cachedResponse) {
    console.log('Using cached response result');
    return cachedResponse;
  }
  
  console.log('No cache hit or forceRefresh=true, generating fresh response');
  
  try {
    // Use mock API if specified or API key is invalid
    if (useMockApi || !ANTHROPIC_API_KEY) {
      console.log('Using mock API for response generation');
      const mockResponse = await mockApiResponse(prompt, { forceRefresh: shouldForceRefresh });
      
      // Only cache the result if not using forceRefresh
      if (!shouldForceRefresh) {
        setCacheResult('response', prompt, mockResponse);
      }
      return mockResponse;
    }
    
    const response = await retryWithDelay(() => 
      anthropicAxios.post('', {
        messages: [{
          role: "user",
          content: prompt
        }],
        model: model,
        max_tokens: 1000,
        temperature: 0.7,
      })
    );
    
    const result = response.data.content[0].text;
    console.log('Successfully generated response');
    
    // Cache the result
    if (!shouldForceRefresh) {
      setCacheResult('response', prompt, result);
    }
    
    return result;
  } catch (error) {
    console.error('Error generating response:', error.response ? error.response.data : error.message);
    return `Error generating response: ${error.message}`;
  }
};

